---
head:
  - - meta
    - property: og:title
      content: 목록으로 정보 전달하기
---

import { DoDont } from '@/components/DoDont/DoDont';

# 목록으로 정보 전달하기

목록은 여러 항목을 한눈에 정리해서 보여 주는 시각 요소예요. 정보를 나열하거나 독자가 빠르게 핵심을 파악해야 할 때 도움이 돼요.

목록은 크게 두 가지로 나뉘어요. 전달하려는 정보의 성격에 맞는 목록을 사용하면 독자가 내용을 더 쉽게 파악할 수 있어요.

- 점 목록: 순서가 중요하지 않은 항목을 나열할 때 사용해요. 예를 들어 특징, 조건, 장점처럼 항목을 나열하는 순서가 바뀌어도 의미가 달라지지 않는 경우에 사용해요.
- 번호 목록: 순서가 중요한 경우에 사용해요. 단계별 절차나 따라해야 할 순서가 있는 설명에 사용해요.

::: info 문장에는 마침표를 붙이세요
AI로 작성된 문서에서는 목록을 문장이 아니라 정보 항목이나 요약 단위로 처리하는 경향이 있어서 문장 끝의 마침표가 생략되는 경우가 많아요.
하지만 한국어에서는 목록 안에 있더라도 문장이라면 마침표를 쓰는 편이 더 자연스러워요.
:::

## 체크 리스트

### ✅ 독립적인 정보를 나열할 때 사용해요

목록은 짧은 정보들을 빠르게 훑어볼 수 있게 할 때 가장 효과적이에요. 각 항목이 서로 독립적일 때 특히 잘 어울려요.

반대로 설명이 하나의 흐름을 이루고 있다면 문장으로 이어 쓰는 편이 이해하기 쉬워요. 앞의 문장이 뒤의 문장을 설명하거나, 원인과 결과처럼 인과관계가 이어지는 설명이 여기에 해당해요. 
이런 내용을 목록으로 나열하면 문장 간 논리 구조가 잘 드러나지 않아서, 독자가 흐름을 다시 파악해야 해요.

<DoDont>

<DoDont.Dont>
- API 요청은 서버와 통신하기 위한 수단입니다.
- 요청을 보내기 전에 인증 정보를 확인해야 합니다.
- 인증 정보가 없으면 요청이 실패할 수 있습니다.
- 요청 형식이 올바른지 확인하세요.
  - 요청이 실패하면 에러 응답을 처리해야 합니다.
  - 에러 응답에는 상태 코드와 메시지가 포함됩니다.
---
각 항목이 독립적인 정보를 전달하는 것처럼 보이지만, 실제로는 하나의 흐름을 가진 설명이에요.
하나의 흐름을 가진 정보가 목록으로 나뉘어서 글의 순서와 인과관계가 잘 드러나지 않아요.
</DoDont.Dont>
<DoDont.Do>

API 요청은 서버와 통신하기 위한 수단입니다. 요청을 보내기 전에 인증 정보를 확인하고, 요청 형식이 올바른지도 함께 점검해야 합니다.

인증 정보가 없거나 요청 형식이 잘못되면 요청이 실패합니다. 이때 서버는 상태 코드와 메시지가 포함된 에러 응답을 반환하므로, 클라이언트에서는 이 에러를 적절히 처리해야 합니다.

---
설명을 문장으로 이어서 요청부터 에러 처리까지의 흐름이 이어져요. 독자가 전체 과정을 자연스럽게 이해할 수 있어요.
</DoDont.Do>

</DoDont>

### ✅ 핵심만 짧게 전달할 수 있을 때 사용해요 

각 항목을 한두 문장으로 써도 의미가 충분히 전달될 때 목록을 사용해요. 반대로 하나의 항목에 설명이 계속 붙으면 읽어야 할 양이 늘어나고, 중요한 내용이 눈에 잘 들어오지 않아요.

이럴 때는 목록 대신 heading을 사용하는 게 좋아요. 
핵심을 드러내는 제목으로 내용을 나누고, 각 항목을 문장으로 풀어 설명하면 정보 구조가 더 분명해지고 가독성도 높아져요.

<DoDont>
<DoDont.Dont>
캐시의 특징은 다음과 같아요.
- 응답 속도 개선: 캐시는 서버에서 계산하거나 조회한 결과를 임시로 저장해요. 같은 요청이 반복되면 서버에 다시 요청하지 않고 캐시된 데이터를 사용해요. 이 과정에서 네트워크 비용과 처리 시간이 줄어들어요. 트래픽이 많은 서비스에서는 성능에 큰 영향을 줘요.
- 서버 부하 감소: 캐시를 사용하면 서버가 동일한 작업을 반복해서 처리하지 않아도 돼요. 데이터베이스 조회 횟수가 줄어들고, 서버 리소스를 더 효율적으로 사용할 수 있어요. 특히 읽기 요청이 많은 환경에서 효과가 커요.
- 저장 위치에 따른 특성: 캐시는 메모리나 디스크에 저장할 수 있어요. 메모리 캐시는 빠르지만 용량이 제한적이고, 디스크 캐시는 용량은 크지만 상대적으로 느려요. 서비스 특성에 따라 적절한 방식을 선택해야 해요.
- 데이터 정합성 문제: 캐시된 데이터가 실제 데이터와 달라질 수 있어요. 캐시 만료 정책을 잘못 설정하면 오래된 데이터를 반환할 수 있어요. 그래서 캐시를 사용할 때는 데이터 갱신 전략을 함께 고려해야 해요.
---
각 항목에 들어간 정보량이 많은데도 목록으로 나열했어요. 이렇게 하면 독자는 항목을 훑어보는 대신, 긴 설명을 하나씩 따라 읽어야 해요.
</DoDont.Dont>
<DoDont.Do>
## 캐시의 특징

### 응답 속도 개선
캐시는 서버에서 계산하거나 조회한 결과를 임시로 저장해요. 같은 요청이 반복되면 서버에 다시 요청하지 않고 캐시된 데이터를 사용해요. 이로 인해 네트워크 비용과 처리 시간이 줄어들고, 전체 응답 속도가 빨라져요.

### 서버 부하 감소
캐시를 사용하면 서버가 동일한 작업을 반복해서 처리하지 않아도 돼요. 데이터베이스 조회 횟수가 줄어들고, 서버 리소스를 더 효율적으로 사용할 수 있어요.

### 저장 위치에 따른 특성
캐시는 메모리나 디스크에 저장할 수 있어요. 메모리 캐시는 빠르지만 용량이 제한적이고, 디스크 캐시는 용량은 크지만 상대적으로 느려요. 서비스 특성에 맞는 방식을 선택해야 해요.

### 데이터 정합성 문제
캐시는 실제 데이터와 차이가 날 수 있어요. 캐시 만료 정책이 적절하지 않으면 오래된 데이터를 반환할 수 있어서, 데이터 갱신 전략을 함께 설계해야 해요.

---
각 특징을 heading으로 분리했어요. 설명이 길어도 제목을 기준으로 내용을 나눠서 읽을 수 있기 때문에 전체 구조와 각 특징의 의미를 쉽게 이해할 수 있어요.
</DoDont.Do>
</DoDont>

::: details 🤔 목록 대신 heading을 사용했더니 문서 구조가 깊어졌어요
목록 대신 heading을 사용했을 때 `####`(H4) 이하로 내려간다면 한 문서에서 너무 많은 내용을 다루고 있다는 신호일 수 있어요. 이럴 때는 문서를 나누는 것을 고려해요. 자세한 내용은 [한 페이지에서는 하나만 다루기 ](https://technical-writing.dev/architecture/one-thing-per-one-page.html#-%EC%A0%9C%EB%AA%A9-%EA%B9%8A%EC%9D%B4%EA%B0%80-h4-%EC%9D%B4%EC%83%81%EC%9D%B4-%EB%90%98%EB%A9%B4-%EB%AC%B8%EC%84%9C%EB%A5%BC-%EB%82%98%EB%88%84%EB%8A%94-%EA%B2%83%EC%9D%84-%EA%B3%A0%EB%A0%A4%ED%95%98%EC%84%B8%EC%9A%94) 문서를 참고하세요.
:::

## 실습 문제

아래 문장을 보고 목록을 어떻게 구성할지 생각해본 뒤, 정답과 비교해 보세요.

### 1. 목록을 사용할지, 다른 방식으로 작성할지 판단해 보세요

> 회원 탈퇴 시 주의사항은 다음과 같아요.  
> 
> - 탈퇴하면 계정을 다시 복구할 수 없어요.  
> - 작성한 게시글과 댓글은 삭제되지 않아요.  
> - 탈퇴 후 같은 이메일로 재가입할 수 있어요.

::: details 정답 확인
**목록을 사용해요.**

문장이 하나의 흐름으로 연관되어 있지 않아서 목록을 사용하면 좋아요.
:::

> HTTP 요청을 처리하는 과정은 다음과 같아요.  
>  
> - 클라이언트가 요청을 전송해요.  
> - 서버는 요청 헤더와 바디를 파싱해요.  
> - 인증 정보가 없으면 요청을 거부해요.  
> - 인증에 실패하면 401 상태 코드를 반환해요.  
> - 인증에 성공하면 비즈니스 로직을 실행해요.

::: details 정답 확인
**문장으로 이어 써요.**

이 내용은 요청 수신 → 파싱 → 인증 → 처리로 이어지는 하나의 흐름이에요. 이런 설명을 목록으로 나열하면 독자가 내용 간 흐름을 다시 파악해야 해서, 문장으로 이어 쓰는 편이 이해하기 쉬워요.

예를 들어 다음과 같이 작성할 수 있어요.
```
HTTP 요청은 클라이언트가 서버로 요청을 전송하면서 시작해요. 서버는 요청을 받으면 먼저 헤더와 바디를 파싱해서 요청 내용을 확인해요. 이 과정에서 인증 정보를 검사하고, 인증 정보가 없거나 유효하지 않으면 요청을 거부해요. 
인증에 실패한 경우 서버는 401 상태 코드를 반환해요. 인증이 성공하면 그다음 단계로 비즈니스 로직을 실행해요.
```
::: 

> 로그 레벨의 종류는 다음과 같아요.  
>  
> - `ERROR`: 시스템에서 더 이상 처리를 진행할 수 없는 문제가 발생했을 때 기록해요. 서비스 운영에 직접적인 영향을 주기 때문에 즉시 확인하고 조치해야 해요.  
>  
> - `WARN`: 당장은 문제가 없지만, 이후 오류로 이어질 수 있는 상황을 기록해요. 반복해서 발생한다면 원인을 분석하는 게 좋아요.

::: details 정답 확인
**heading으로 나눠서 작성해요.**

각 항목의 내용이 너무 길어요. 이런 경우에는 heading을 사용해서 설명하는 편이 더 이해하기 쉬워요.

예를 들어 다음과 같이 작성할 수 있어요.
```
## 로그 레벨의 종류

### `ERROR`
시스템에서 더 이상 처리를 진행할 수 없는 문제가 발생했을 때 기록해요. 서비스 운영에 직접적인 영향을 주기 때문에 즉시 확인하고 조치해야 해요.

### `WARN`
당장은 문제가 없지만, 이후 오류로 이어질 수 있는 상황을 기록해요. 반복해서 발생한다면 원인을 분석하는 게 좋아요.
```
::: 